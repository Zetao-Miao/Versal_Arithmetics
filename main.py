import matplotlib.pyplot as plt
import matplotlib.ticker as ticker


# Class for each column in the bit heap
class Column:

    def __init__(self, idx):  # instance initialized with index of the column in the bit heap
        self.index = idx
        self.numberOfBits = 0  # number of bits in the column
        self.numberOfLockedBits = 0  # number of bits that are already assigned to a counter in the column
        self.numberOfFreeBits = 0  # number of bits that are not yet assigned to a counter in the column
        self.numberOfBits_nextRound = 0  # number of bits that will be generated by counters and put in the column
        self.allBits = []  # indexes of all bits in the column, including free ones and locked ones
        self.lockedBits = []  # indexes of bits that are already assigned to a counter in the column
        self.freeBits = []  # indexes of bits that are noy yet assigned to a counter in the column
        self.allBits_nextRound = []  # indexes of bits that will be generated by counters and put in the column

    def __repr__(self):
        return f"Instance {self.index} of Class Column: \n" \
               f"Number of Bits: {self.numberOfBits} \n" \
               f"All Bits: {self.allBits} \n" \
               f"Number of Free Bits: {self.numberOfFreeBits} \n" \
               f"Free Bits: {self.freeBits} \n" \
               f"Number of Locked Bits: {self.lockedBits} \n" \
               f"Locked Bits: {self.lockedBits} \n" \
               f"Number of Bits Next Round: {self.numberOfBits_nextRound} \n" \
               f"All Bits Next Round: {self.allBits_nextRound} \n"

    def addbits(self, n):  # function used to establish the whole bit heap -- at n bits in the column
        self.numberOfBits += n
        self.numberOfFreeBits += n
        if not self.allBits:
            addidx = [i for i in range(n)]
        else:
            maxidx = max(self.freeBits)
            addidx = [maxidx + i + 1 for i in range(n)]
        self.allBits.extend(addidx)
        self.freeBits.extend(addidx)

    def lockbits(self, n):  # function used to assign bits to a counter
        self.numberOfFreeBits -= n
        self.numberOfLockedBits += n
        self.lockedBits.extend(self.freeBits[:n])  # add first n bits in the list of free bits to the locked one
        self.freeBits = self.freeBits[n:]  # remove the first n bits from the list of free bits

    def addbits_nextround(self, n):  # function used to store n new bits generated by counters temporarily
        self.numberOfBits_nextRound += n
        if not self.allBits_nextRound:
            addidx = [i for i in range(n)]
        else:
            maxidx = max(self.allBits_nextRound)
            addidx = [maxidx + i + 1 for i in range(n)]
        self.allBits_nextRound.extend(addidx)

    def update(self):  # function used to update the column for the next round
        indexes_old = []  # indexes of free bits left in the current round
        indexes_new = []  # indexes of those free bits being in the next round
        if self.numberOfFreeBits != 0:  # map the free bits left in current round to the next round
            indexes_old.extend(self.freeBits)
            if not self.allBits_nextRound:
                indexes_new.extend(i for i in range(self.numberOfFreeBits))
            else:
                indexes_new.extend([max(self.allBits_nextRound) + i + 1 for i in range(self.numberOfFreeBits)])
            self.numberOfBits_nextRound += self.numberOfFreeBits
            self.allBits_nextRound.extend(indexes_new)
        self.numberOfBits = self.numberOfBits_nextRound  # update everything of the column
        self.numberOfLockedBits = 0
        self.numberOfFreeBits = self.numberOfBits_nextRound
        self.numberOfBits_nextRound = 0
        self.allBits = self.allBits_nextRound
        self.lockedBits = []
        self.freeBits = self.allBits_nextRound
        self.allBits_nextRound = []
        return indexes_old, indexes_new  # return the mapping relationship for verilog assignment


# Class for the whole bit heap evolution
class BitHeap:
    def __init__(self, n):  # initialized with a generation of the original bit heap
        self.size = [n, n]
        self.heap = [Column(i) for i in range(n+10)]
        # for p in range(n // 2):
        #     for q in range(2 * p, 2 * n - 2 * p):
        #         self.heap[q].addbits(1)
        #     self.heap[2 * p].addbits(1)
        # self.heap[n].addbits(1)

    def __repr__(self):
        size_str = f"Size of the Bit Heap: {self.size}"
        columns_str = "Columns of the Bit Heap: \n"
        for col in self.heap:
            columns_str = columns_str + col.__repr__()
        return size_str + columns_str

    def visualize(self, figureName):  # function to visualize the bit heap
        x_plot = []
        y_plot = []
        for i in range(self.size[1]):
            for j in range(self.heap[i].numberOfBits):
                x_plot.append(i)
                y_plot.append(j)
        fig, ax = plt.subplots(figsize=(self.size[1], self.size[0]))
        ax.scatter(x_plot, y_plot, color='black', s=120, marker='o')  # Use Black Dots
        ax.invert_xaxis()  # Invert the x-axis
        ax.xaxis.set_major_locator(ticker.MultipleLocator(1))  # Set the Index for Columns of the Bit Heap
        ax.set_xlim(self.size[1] - 0.5, -0.5)
        ax.tick_params(axis='x', length=0, labelsize=20)
        ax.tick_params(axis='x', pad=25)
        ax.set_aspect('equal')
        ax.set_yticks([])  # Hide the y-axis
        ax.set_xlabel('')  # Hide Labels for both x-axis and y-axis
        ax.set_ylabel('')
        for spine in ['top', 'right', 'left', 'bottom']:  # Hide the Spine of the Plot
            ax.spines[spine].set_visible(False)
        plt.tight_layout()  # Use Tight Layout (less blank margin)
        plt.savefig(figureName, dpi=300, bbox_inches='tight')  # Save the Image

    def check_lastlayer(self):  # function to check whether the last layer of counters can be applied
        for i in range(6, self.size[1]):
            if self.heap[i].numberOfFreeBits > 4:
                return False
        return True

    def check_finished(self):
        for i in range(self.size[1]):
            if self.heap[i].numberOfFreeBits != 1:
                return False
        return True

    def check_average_height(self):
        heightSum = 0
        for i in range(self.size[1]):
            heightSum += self.heap[i].numberOfFreeBits
        return heightSum/self.size[1]

    def update(self):
        assign_dict = {}
        for col in range(self.size[1]):
            assign_dict[col] = self.heap[col].update()
        return assign_dict


# Class for a counter / counter chain
class Counter:

    def __init__(self, name, inputs, type, bitheap: BitHeap):
        self.name = name  # just a name, for easier human recognition
        self.inputs = inputs  # Location of the counter inputs, a list of (row index, column index)
        self.type = type  # string, can be "Chain", "Tail", "Head", "Adder", ...
        self.outputs = []  # Location of the counter outputs, (row index, column index)
        self.input_columns = []  # indexes of columns of input bits
        self.input_numberOfRows = []  # number of rows of each input column
        self.output_columns = []  # indexes of columns of input bits
        self.output_msbCascade = False  # flag noting whether the output MSB is used by another counter in current layer
        self.compute_columns()
        self.commit_counter(bitheap)

    def __repr__(self):
        return f"Counter {self.name}: \n" \
               f"Type: {self.type} \n" \
               f"Inputs: {self.inputs} \n" \
               f"Input Columns: {self.input_columns} \n" \
               f"Input Number of Rows: {self.input_numberOfRows} \n" \
               f"Outputs: {self.outputs} \n" \
               f"Output Columns: {self.output_columns} \n" \
               f"MSB Cascade: {self.output_msbCascade} \n"

    def compute_columns(self):  # compute the columns of input/output bits of the counter based on the type
        columns = [t[1] for t in self.inputs]
        in_min = min(columns)
        in_max = max(columns)
        self.input_columns = list(range(in_min, in_max + 1))
        for col in self.input_columns:
            self.input_numberOfRows.append(sum(1 for _, cols in self.inputs if cols == col))
        if self.type == "adder4" or self.type == "tail":
            self.output_columns.extend(list(range(in_min, in_max + 3)))
        elif self.type == "head" or self.type == "terminalAdder":
            self.output_columns.extend(list(range(in_min, in_max + 1)))
        else:
            self.output_columns.extend(list(range(in_min, in_max + 2)))

    def commit_counter(self, bitheap: BitHeap):  # apply the counter to the bit heap
        for i in range(len(self.input_columns)):  # lock input bits in the bit heap
            bitheap.heap[self.input_columns[i]].lockbits(self.input_numberOfRows[i])
        if not self.output_msbCascade:  # add output bits to the next round list of the bit heap
            for j in self.output_columns:
                bitheap.heap[j].addbits_nextround(1)
                self.outputs.append((bitheap.heap[j].allBits_nextRound[-1], j))  # fill in the outputs list
        else:
            for j in self.output_columns[:-2]:
                bitheap.heap[j].addbits_nextround(1)
                self.outputs.append((bitheap.heap[j].allBits_nextRound[-1], j))


def counter223_applicable(col, bitheap: BitHeap, chained):
    if chained:
        if bitheap.heap[col].numberOfFreeBits < 2 or \
                bitheap.heap[col + 1].numberOfFreeBits < 2 or \
                bitheap.heap[col + 2].numberOfFreeBits < 2:
            return False
    else:
        if bitheap.heap[col].numberOfFreeBits < 3 or \
                bitheap.heap[col + 1].numberOfFreeBits < 2 or \
                bitheap.heap[col + 2].numberOfFreeBits < 2:
            return False
    return True


def counter223_necessary(col, bitheap: BitHeap, chained):
    if chained:
        if 4 <= bitheap.heap[col].numberOfFreeBits + bitheap.heap[col].numberOfBits_nextRound <= 5 and \
                4 <= bitheap.heap[col+1].numberOfFreeBits + bitheap.heap[col+1].numberOfBits_nextRound <= 5 and \
                4 <= bitheap.heap[col+2].numberOfFreeBits + bitheap.heap[col+2].numberOfBits_nextRound <= 5:
            return True
    else:
        if 5 <= bitheap.heap[col].numberOfFreeBits + bitheap.heap[col].numberOfBits_nextRound <= 6 and \
                4 <= bitheap.heap[col+1].numberOfFreeBits + bitheap.heap[col+1].numberOfBits_nextRound <= 5 and \
                4 <= bitheap.heap[col+2].numberOfFreeBits + bitheap.heap[col+2].numberOfBits_nextRound <= 5:
            return True
    return False


def counter15_applicable(col, bitheap: BitHeap, chained):
    if chained:
        if bitheap.heap[col].numberOfFreeBits < 4:
            return False
    else:
        if bitheap.heap[col].numberOfFreeBits < 5:
            return False
    if bitheap.heap[col+1].numberOfFreeBits == 0:
        return False
    return True


def counter15_necessary(col, bitheap: BitHeap, chained):
    if chained:
        if bitheap.heap[col].numberOfFreeBits + bitheap.heap[col].numberOfBits_nextRound >= 6:
            return True
        if bitheap.heap[col].numberOfFreeBits + bitheap.heap[col].numberOfBits_nextRound == 5 and \
                bitheap.heap[col+1].numberOfFreeBits + bitheap.heap[col+1].numberOfBits_nextRound >= 4 and \
                (bitheap.heap[col+2].numberOfFreeBits + bitheap.heap[col+2].numberOfBits_nextRound <= 3 or
                bitheap.heap[col+2].numberOfFreeBits + bitheap.heap[col+2].numberOfBits_nextRound >= 6):
            return True
    else:
        if bitheap.heap[col].numberOfFreeBits + bitheap.heap[col].numberOfBits_nextRound >= 7:
            return True
        if bitheap.heap[col].numberOfFreeBits + bitheap.heap[col].numberOfBits_nextRound == 6 and \
                bitheap.heap[col+1].numberOfFreeBits + bitheap.heap[col+1].numberOfBits_nextRound >= 4 and \
                (bitheap.heap[col+2].numberOfFreeBits + bitheap.heap[col+2].numberOfBits_nextRound <= 3 or
                bitheap.heap[col+2].numberOfFreeBits + bitheap.heap[col+2].numberOfBits_nextRound >= 6):
            return True
    return False


def counter3_applicable(col, bitheap: BitHeap, chained):
    if chained:
        if bitheap.heap[col].numberOfFreeBits < 2:
            return False
    else:
        if bitheap.heap[col].numberOfFreeBits < 3:
            return False
    return True


def counter3_necessary(col, bitheap: BitHeap, chained):
    if chained:
        if 4 <= bitheap.heap[col].numberOfFreeBits + bitheap.heap[col].numberOfBits_nextRound <= 5 and \
            bitheap.heap[col+1].numberOfFreeBits + bitheap.heap[col+1].numberOfBits_nextRound <= 3:
            return True
    else:
        if 5 <= bitheap.heap[col].numberOfFreeBits + bitheap.heap[col].numberOfBits_nextRound <= 6 and \
                (bitheap.heap[col+1].numberOfFreeBits + bitheap.heap[col+1].numberOfBits_nextRound <= 3 or
                4 <= bitheap.heap[col+1].numberOfFreeBits + bitheap.heap[col+1].numberOfBits_nextRound <= 5 and
                bitheap.heap[col+2].numberOfFreeBits + bitheap.heap[col+2].numberOfBits_nextRound <= 3):
            return True
    return False


class Layer:

    def __init__(self, idx, startcolumn, bitheap: BitHeap, last_layer_flag):
        self.index = idx
        self.counter_list = []
        self.assign_list = []
        self.start_column = startcolumn
        if last_layer_flag:
            self.apply_lastlayer(bitheap)
        else:
            self.apply_counters(bitheap)

    def __repr__(self):
        layer_str = f"Layer {self.index} Counters: \n"
        assign_str = f"Layer {self.index} Assignments: \n"
        for counter in self.counter_list:
            layer_str = layer_str + counter.__repr__()
        for assignment in self.assign_list:
            assign_str = assign_str + f"{assignment} \n"
        return layer_str, assign_str

    def apply_counters(self, bitheap: BitHeap):
        if self.index == 0:
            tail_inputs = [(bitheap.heap[0].freeBits[0], 0),
                           (bitheap.heap[0].freeBits[1], 0),
                           (bitheap.heap[1].freeBits[0], 1),
                           (bitheap.heap[2].freeBits[0], 2),
                           (bitheap.heap[2].freeBits[1], 2),
                           (bitheap.heap[2].freeBits[2], 2)]
            self.counter_list.append(Counter("Tail", tail_inputs, "tail", bitheap))
        self.compressBitHeap(bitheap, self.start_column)
        assign_dict = bitheap.update()
        for col in assign_dict:
            for i in range(len(assign_dict[col][0])):
                self.assign_list.append(((assign_dict[col][0][i], col), (assign_dict[col][1][i], col)))

    def findStartColumnForTail(self, bitheap: BitHeap):
        i = 0
        while bitheap.heap[i].numberOfBits <= 3 and i < bitheap.size[1]-1:
            i += 1
        for j in range(i):
            if 2 <= bitheap.heap[j].numberOfBits <= 3:
                return True, j
        return False, bitheap.size[1]

    def findEndColumnForTail(self, bitheap: BitHeap, startColumn):
        for i in range(startColumn, bitheap.size[1]):
            if bitheap.heap[i].numberOfBits >= 3:
                return True, i
        return False, bitheap.size[1]

    def compressTail(self, bitheap: BitHeap):
        tailStartFlag, tailStart = self.findStartColumnForTail(bitheap)
        tailEndFlag, tailEnd = self.findEndColumnForTail(bitheap, tailStart+1)
        print(tailStartFlag)
        print(tailStart)
        print(tailEndFlag)
        print(tailEnd)
        if tailStartFlag:
            inputs = []
            for i in range(tailStart, tailEnd):
                for j in bitheap.heap[i].freeBits:
                    inputs.append((j, i))
            self.counter_list.append(Counter("twoOperand", inputs, "adder", bitheap))
            if not tailEndFlag:
                return True, tailEnd
        else:
            if not tailEndFlag:
                return True, tailEnd
        return False, tailEnd


    def compressWithQuaternary(self, startColumn, bitheap: BitHeap):
        # terminationFlag = False
        for addernum in range(int(bitheap.check_average_height()/2)-1):
            i = startColumn
            # terminationFlag = True
            while i < bitheap.size[1]:
                j = i
                inputs = []
                while bitheap.heap[j].numberOfFreeBits >= 4:
                    if (j == i or j == i + 1) and bitheap.heap[j].numberOfFreeBits >= 5:
                        inputs.extend([(bitheap.heap[j].freeBits[0], j),
                                       (bitheap.heap[j].freeBits[1], j),
                                       (bitheap.heap[j].freeBits[2], j),
                                       (bitheap.heap[j].freeBits[3], j),
                                       (bitheap.heap[j].freeBits[4], j)])
                    else:
                        inputs.extend([(bitheap.heap[j].freeBits[0], j),
                                       (bitheap.heap[j].freeBits[1], j),
                                       (bitheap.heap[j].freeBits[2], j),
                                       (bitheap.heap[j].freeBits[3], j)])
                    j += 1
                if j > i+1:
                    self.counter_list.append(Counter("quaternary", inputs, "adder4", bitheap))
                    # terminationFlag = False
                i += 1

    def compressBitHeap(self, bitheap: BitHeap, startColumn):
        terminationFlag = False
        while not terminationFlag:
            i = startColumn
            terminationFlag = True
            while i < bitheap.size[1]-4:
                if counter223_applicable(i, bitheap, False) and counter223_necessary(i, bitheap, False):
                    j = i + 3
                    flag223 = False
                    inputs = [(bitheap.heap[i].freeBits[0], i),
                                    (bitheap.heap[i].freeBits[1], i),
                                    (bitheap.heap[i].freeBits[2], i),
                                    (bitheap.heap[i + 1].freeBits[0], i + 1),
                                    (bitheap.heap[i + 1].freeBits[1], i + 1),
                                    (bitheap.heap[i + 2].freeBits[0], i + 2),
                                    (bitheap.heap[i + 2].freeBits[1], i + 2)]
                    if counter223_applicable(j, bitheap, True) and counter223_necessary(j, bitheap, True):
                        inputs.extend([(bitheap.heap[i+3].freeBits[0], i+3),
                                             (bitheap.heap[i+3].freeBits[1], i+3),
                                             (bitheap.heap[i+4].freeBits[0], i+4),
                                             (bitheap.heap[i+4].freeBits[1], i+4),
                                             (bitheap.heap[i+5].freeBits[0], i+5),
                                             (bitheap.heap[i+5].freeBits[1], i+5)])
                        self.counter_list.append(Counter("223", inputs, "row", bitheap))
                        flag223 = True
                    while counter15_applicable(j, bitheap, True) and counter15_necessary(j, bitheap, True):
                        inputs.extend([(bitheap.heap[j].freeBits[0], j),
                                       (bitheap.heap[j].freeBits[1], j),
                                       (bitheap.heap[j].freeBits[2], j),
                                       (bitheap.heap[j].freeBits[3], j),
                                       (bitheap.heap[j+1].freeBits[0], j+1)])
                        j += 2
                    if j > i+3:
                        self.counter_list.append(Counter("22315", inputs, "row", bitheap))
                    elif not flag223:
                        self.counter_list.append(Counter("223", inputs, "individual", bitheap))
                    terminationFlag = False
                elif counter3_applicable(i, bitheap, False) and counter3_necessary(i, bitheap, False):
                    inputs = [(bitheap.heap[i].freeBits[0], i),
                              (bitheap.heap[i].freeBits[1], i),
                              (bitheap.heap[i].freeBits[2], i)]
                    self.counter_list.append(Counter("3", inputs, "individual", bitheap))
                    terminationFlag = False
                elif counter15_applicable(i, bitheap, False) and counter15_necessary(i, bitheap, False):
                    j = i + 2
                    inputs = [(bitheap.heap[i].freeBits[0], i),
                              (bitheap.heap[i].freeBits[1], i),
                              (bitheap.heap[i].freeBits[2], i),
                              (bitheap.heap[i].freeBits[3], i),
                              (bitheap.heap[i].freeBits[4], i),
                              (bitheap.heap[i+1].freeBits[0], i+1)]
                    while counter15_applicable(j, bitheap, True) and counter15_necessary(j, bitheap, True):
                        inputs.extend([(bitheap.heap[j].freeBits[0], j),
                                       (bitheap.heap[j].freeBits[1], j),
                                       (bitheap.heap[j].freeBits[2], j),
                                       (bitheap.heap[j].freeBits[3], j),
                                       (bitheap.heap[j+1].freeBits[0], j+1)])
                        j += 2
                    if j > i+2:
                        self.counter_list.append(Counter("15", inputs, "row", bitheap))
                    else:
                        self.counter_list.append(Counter("15", inputs, "individual", bitheap))
                    terminationFlag = False
                i += 1

    def apply_lastlayer(self, bitheap: BitHeap):
        counter_inputs = []
        for col in range(3, bitheap.size[1]-4):
            for row in bitheap.heap[col].freeBits:
                counter_inputs.append((row, col))
        self.counter_list.append(Counter("quaternary", counter_inputs, "terminalAdder", bitheap))
        head_inputs = [(bitheap.heap[bitheap.size[1]-4].freeBits[0], bitheap.size[1]-4),
                       (bitheap.heap[bitheap.size[1]-4].freeBits[1], bitheap.size[1]-4),
                       (bitheap.heap[bitheap.size[1]-3].freeBits[0], bitheap.size[1]-3),
                       (bitheap.heap[bitheap.size[1]-3].freeBits[1], bitheap.size[1]-3),
                       (bitheap.heap[bitheap.size[1]-2].freeBits[0], bitheap.size[1]-2),
                       (bitheap.heap[bitheap.size[1]-1].freeBits[0], bitheap.size[1]-1)]
        self.counter_list.append(Counter("Head", head_inputs, "head", bitheap))
        assign_dict = bitheap.update()
        for col in assign_dict:
            for i in range(len(assign_dict[col][0])):
                self.assign_list.append(((assign_dict[col][0][i], col), (assign_dict[col][1][i], col)))


def do_compression(bitheap: BitHeap, n):
    layer_list = []
    layer_idx = 1
    layer_list.append(Layer(0, 6, bitheap, bitheap.check_lastlayer()))
    bitheap.visualize(f"{n}Times{n}_Layer0")
    while not bitheap.check_finished():
        layer_list.append(Layer(layer_idx, 6, bitheap, bitheap.check_lastlayer()))
        bitheap.visualize(f"{n}Times{n}_Layer{layer_idx}")
        layer_idx += 1
    return layer_list

def countLUTs(layers, multWidth):
    LUTCount = 0
    for layer in layers:
        for counter in layer.counter_list:
            if counter.type == "adder":
                LUTCount += len(counter.input_columns)
            if counter.type == "individual":
                if counter.name == "3":
                    LUTCount += 1
                else:
                    LUTCount += 2
            if counter.type == "row":
                if counter.name == "22315":
                    LUTCount += len(counter.input_columns)-1
                else:
                    LUTCount += len(counter.input_columns)
            if counter.type == "terminalAdder":
                LUTCount += 2*len(counter.input_columns)
            if counter.type == "adder4":
                LUTCount += 2*len(counter.input_columns)
            if counter.type == "head":
                LUTCount += 2
            if counter.type == "tail":
                LUTCount += 3
    print(f"Total number of LUTs for The Compressor Tree: {LUTCount}")
    print(f"Total number of LUTs for The Multiplier: {LUTCount+multWidth*multWidth//4+multWidth//4+(multWidth%4)//2}")


def gen_sv_bitheap(width, stage, insert_reg):
    sv_code = f"""\
module Mult_LUTs_{width} #(
    parameter PIPE_STAGE = {stage},
    parameter IN_WIDTH   = {width}
)(
    input  logic                    clk,
    input  logic                    reset,
    input  logic                    in_valid,
    input  logic [IN_WIDTH-1   : 0] A,
    input  logic [IN_WIDTH-1   : 0] B,
    output logic                    out_valid,
    output logic [2*IN_WIDTH-1 : 0] P
    );

    logic [2            : 0] Booth_Gen_A [IN_WIDTH/2-1 : 0];
    logic [2            : 0] Booth_Gen_B [IN_WIDTH/2-1 : 0];
    logic [IN_WIDTH     : 0] Booth_Gen_O [IN_WIDTH/2-1 : 0];
    logic [2*IN_WIDTH-1 : 0] Bit_Heap    [IN_WIDTH/2   : 0];
    logic [PIPE_STAGE-1 : 0] valid_reg;
    logic [1            : 0] Adder_to_Counter;
    logic                    Booth_Sign_NC;

    always_ff @(posedge clk) begin
        if (reset) begin
            valid_reg <= 'b0;
        end else begin
            if (PIPE_STAGE > 1) begin
                valid_reg[PIPE_STAGE-1 : 1] <= valid_reg[PIPE_STAGE-2 : 0];
            end
            valid_reg[0] <= in_valid;
        end
    end
    assign out_valid = valid_reg[PIPE_STAGE-1];

    // Partial Product Generation for Booth Recoding
    generate
        genvar i, j;
        for (i = 0; i < IN_WIDTH/2; i = i + 1) begin
            for (j = 0; j < IN_WIDTH/2; j = j + 1) begin
                R4_Booth_Gen #(.OUTREG("{insert_reg}"))
                R4_Booth_Gen_inst(
                    .clk(clk                      ),
                    .A  (Booth_Gen_A[j]           ),
                    .B  (Booth_Gen_B[i]           ),
                    .O  (Booth_Gen_O[i][2*j+1:2*j]));                
            end
            assign Booth_Gen_A[i] = i == 0 ? {{A[1:0], 1'b0}} : A[2*i+1:2*i-1];
            assign Booth_Gen_B[i] = i == 0 ? {{B[1:0], 1'b0}} : B[2*i+1:2*i-1];
        end
    endgenerate

    generate
        genvar p;
        for (p = 0; p < IN_WIDTH/4; p = p + 1) begin
            Booth_Sign_Gen #(.OUTREG("{insert_reg}"))
            Booth_Sign_Gen_inst(
                .clk(clk                                                       ),
                .A  (A[IN_WIDTH-1]                                             ),
                .B  (p == 0 ? {{B[3:0], 1'b0}} : {{B[4*p+3:4*p-1]}}                ),
                .O  ({{Booth_Gen_O[2*p+1][IN_WIDTH], Booth_Gen_O[2*p][IN_WIDTH]}}));
        end
        if (IN_WIDTH % 4 == 2) begin
            Booth_Sign_Gen #(.OUTREG("{insert_reg}"))
            Booth_Sign_Gen_inst_rem(
                .clk(clk                                                 ),
                .A  (A[IN_WIDTH-1]                                       ),
                .B  ({{2'b0, B[IN_WIDTH-1:IN_WIDTH-3]}}                    ),
                .O  ({{Booth_Sign_NC, Booth_Gen_O[IN_WIDTH/2-1][IN_WIDTH]}}));
        end
    endgenerate

    // Bit Heap Generation from Booth Partial Product
    generate
        genvar k;
        for (k = 0; k < IN_WIDTH/2; k = k + 1) begin
            assign Bit_Heap[k][IN_WIDTH-1 : 2*k] = Booth_Gen_O[k][0 +: (IN_WIDTH-2*k)];
            if (k == IN_WIDTH/2-1) begin
                assign Bit_Heap[k][IN_WIDTH +: 2*(IN_WIDTH/2-k)] = {{1'b1, Booth_Gen_O[IN_WIDTH/2-1-k][IN_WIDTH]}};
            end else begin
                assign Bit_Heap[k][IN_WIDTH +: 2*(IN_WIDTH/2-k)] = {{1'b1, Booth_Gen_O[IN_WIDTH/2-1-k][IN_WIDTH], Booth_Gen_O[IN_WIDTH/2-1-k][IN_WIDTH-1 -: 2*(IN_WIDTH/2-1-k)]}};
            end"""
    if insert_reg == "FALSE":
        sv_code += f"""
            assign Bit_Heap[k+1][2*k] = B[2*k+1];
        end
        assign Bit_Heap[IN_WIDTH/2][IN_WIDTH] = 1'b1;
    endgenerate

    // Compressor Network Generation -- Controlled and Generated by Python"""
    else:
        sv_code += f"""
            always @(posedge clk) begin
                Bit_Heap[k+1][2*k] <= B[2*k+1];
            end
        end
        always @(posedge clk) begin
            Bit_Heap[IN_WIDTH/2][IN_WIDTH] <= 1'b1;
        end
    endgenerate

    // Compressor Network Generation -- Controlled and Generated by Python"""
    return sv_code


def gen_sv_onecounter(counter: Counter, layer_idx, counter_idx, instname, insert_reg):
    if counter.type == "tail":
        sv_code = f"""
    Counter_312 #(.OUTREG("{insert_reg}"                    ),
                  .USETNM("LAYER{layer_idx}_COUNTER_312_INST{counter_idx}"),
                  .RLOCNM("X0Y0"                    ),
                  .LEAVEC("FALSE"                    ))
    Layer{layer_idx}_Counter_312_inst{counter_idx}(
        .clk(clk                                             ),
        .C0 ({{Bit_Heap[1][0], Bit_Heap[0][0]}}                ),
        .C1 (Bit_Heap[0][1]                                  ),
        .C2 ({{Bit_Heap[0][2], Bit_Heap[1][2], Bit_Heap[2][2]}}),
        .O  ({{Bit_Heap_L0[0][3], Bit_Heap_L0[0][2:0]}}        ));

    CounterC_312 #(.OUTREG("{insert_reg}"                    ),
                   .USETNM("LAYER{layer_idx}_COUNTERC_312_INST{counter_idx}"),
                   .RLOCNM("X0Y0"                     ))
    Layer{layer_idx}_CounterC_312_inst{counter_idx}(
        .clk(clk                                             ),
        .C0 ({{Bit_Heap[1][0], Bit_Heap[0][0]}}                ),
        .C1 (Bit_Heap[0][1]                                  ),
        .C2 ({{Bit_Heap[0][2], Bit_Heap[1][2], Bit_Heap[2][2]}}),
        .O  (Bit_Heap_L0[0][4]                               ));
        """
        xdc_code = f"""
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_312_inst{counter_idx}/LUT6_2_inst1/LUT5]
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_312_inst{counter_idx}/LUT6_2_inst1/LUT6]
set_property BEL       A5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_312_inst{counter_idx}/LUT6_2_inst0/LUT5]
set_property BEL       A6LUT   [get_cells {instname}/Layer{layer_idx}_Counter_312_inst{counter_idx}/LUT6_2_inst0/LUT6]
set_property BEL       B5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_312_inst{counter_idx}/LUT6_2_inst1/LUT5]
set_property BEL       B6LUT   [get_cells {instname}/Layer{layer_idx}_Counter_312_inst{counter_idx}/LUT6_2_inst1/LUT6]
set_property BEL       AFF     [get_cells {instname}/Layer{layer_idx}_Counter_312_inst{counter_idx}/O_reg_reg[0]]
set_property BEL       AFF2    [get_cells {instname}/Layer{layer_idx}_Counter_312_inst{counter_idx}/O_reg_reg[1]]
set_property BEL       BFF     [get_cells {instname}/Layer{layer_idx}_Counter_312_inst{counter_idx}/O_reg_reg[2]]
        """
        return sv_code, xdc_code

    elif counter.type == "row" and counter.name == "22315":
        length = (max(counter.input_columns) - min(counter.input_columns) - 2) // 2
        str_CL_00 = f"{{"
        str_CL_01 = f"{{"
        str_CL_02 = f"{{"
        str_CL_03 = f"{{"
        str_CL_10 = f"{{"
        str_O = f"{{"
        if layer_idx == 0:
            str_C0 = f"{{Bit_Heap[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                     f"Bit_Heap[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                     f"Bit_Heap[{counter.inputs[2][0]}][{counter.inputs[2][1]}]}}"
            str_C1 = f"{{Bit_Heap[{counter.inputs[3][0]}][{counter.inputs[3][1]}], " \
                     f"Bit_Heap[{counter.inputs[4][0]}][{counter.inputs[4][1]}]}}"
            str_C2 = f"{{Bit_Heap[{counter.inputs[5][0]}][{counter.inputs[5][1]}], " \
                     f"Bit_Heap[{counter.inputs[6][0]}][{counter.inputs[6][1]}]}}"
            for i in range(1, length + 1):
                str_CL_00 += f"Bit_Heap[{counter.inputs[(length - i) * 5 + 7][0]}][{counter.inputs[(length - i) * 5 + 7][1]}]"
                str_CL_01 += f"Bit_Heap[{counter.inputs[(length - i) * 5 + 8][0]}][{counter.inputs[(length - i) * 5 + 8][1]}]"
                str_CL_02 += f"Bit_Heap[{counter.inputs[(length - i) * 5 + 9][0]}][{counter.inputs[(length - i) * 5 + 9][1]}]"
                str_CL_03 += f"Bit_Heap[{counter.inputs[(length - i) * 5 + 10][0]}][{counter.inputs[(length - i) * 5 + 10][1]}]"
                str_CL_10 += f"Bit_Heap[{counter.inputs[(length - i) * 5 + 11][0]}][{counter.inputs[(length - i) * 5 + 11][1]}]"
                if i != length:
                    str_CL_00 += ", "
                    str_CL_01 += ", "
                    str_CL_02 += ", "
                    str_CL_03 += ", "
                    str_CL_10 += ", "
                else:
                    str_CL_00 += f"}}"
                    str_CL_01 += f"}}"
                    str_CL_02 += f"}}"
                    str_CL_03 += f"}}"
                    str_CL_10 += f"}}"
        else:
            str_C0 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                     f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                     f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[2][0]}][{counter.inputs[2][1]}]}}"
            str_C1 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[3][0]}][{counter.inputs[3][1]}], " \
                     f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[4][0]}][{counter.inputs[4][1]}]}}"
            str_C2 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[5][0]}][{counter.inputs[5][1]}], " \
                     f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[6][0]}][{counter.inputs[6][1]}]}}"
            for i in range(1, length + 1):
                str_CL_00 += f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[(length - i) * 5 + 7][0]}][{counter.inputs[(length - i) * 5 + 7][1]}]"
                str_CL_01 += f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[(length - i) * 5 + 8][0]}][{counter.inputs[(length - i) * 5 + 8][1]}]"
                str_CL_02 += f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[(length - i) * 5 + 9][0]}][{counter.inputs[(length - i) * 5 + 9][1]}]"
                str_CL_03 += f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[(length - i) * 5 + 10][0]}][{counter.inputs[(length - i) * 5 + 10][1]}]"
                str_CL_10 += f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[(length - i) * 5 + 11][0]}][{counter.inputs[(length - i) * 5 + 11][1]}]"
                if i != length:
                    str_CL_00 += ", "
                    str_CL_01 += ", "
                    str_CL_02 += ", "
                    str_CL_03 += ", "
                    str_CL_10 += ", "
                else:
                    str_CL_00 += f"}}"
                    str_CL_01 += f"}}"
                    str_CL_02 += f"}}"
                    str_CL_03 += f"}}"
                    str_CL_10 += f"}}"
        for j in range(len(counter.outputs)):
            str_O += f"Bit_Heap_L{layer_idx}[{counter.outputs[len(counter.outputs) - 1 - j][0]}][{counter.outputs[len(counter.outputs) - 1 - j][1]}]"
            if j == len(counter.outputs) - 1:
                str_O += f"}}"
            else:
                str_O += ", "
        sv_code = f"""
    Counter_Chain #(.LENGTH({length}                       ),
                    .OUTREG("{insert_reg}"                     ),
                    .USETNM("LAYER{layer_idx}_COUNTER_CHAIN_INST{counter_idx}"))
    Layer{layer_idx}_Counter_Chain_inst{counter_idx}(
        .clk  (clk),
        .C0   ({str_C0}),
        .C1   ({str_C1}),
        .C2   ({str_C2}),
        .CL_00({str_CL_00}),
        .CL_01({str_CL_01}),
        .CL_02({str_CL_02}),
        .CL_03({str_CL_03}),
        .CL_10({str_CL_10}),
        .O    ({str_O}));
        """
        xdc_code = ""
        return sv_code, xdc_code

    elif counter.type == "row" and counter.name == "15":
        length = (max(counter.input_columns) - min(counter.input_columns) - 1) // 2
        str_CL_00 = f"{{"
        str_CL_01 = f"{{"
        str_CL_02 = f"{{"
        str_CL_03 = f"{{"
        str_CL_10 = f"{{"
        str_O = f"{{"
        if layer_idx == 0:
            str_C0 = f"{{Bit_Heap[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                     f"Bit_Heap[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                     f"Bit_Heap[{counter.inputs[2][0]}][{counter.inputs[2][1]}], " \
                     f"Bit_Heap[{counter.inputs[3][0]}][{counter.inputs[3][1]}], " \
                     f"Bit_Heap[{counter.inputs[4][0]}][{counter.inputs[4][1]}]}}"
            str_C1 = f"{{Bit_Heap[{counter.inputs[5][0]}][{counter.inputs[5][1]}]}}"
            for i in range(1, length + 1):
                str_CL_00 += f"Bit_Heap[{counter.inputs[(length - i) * 5 + 6][0]}][{counter.inputs[(length - i) * 5 + 6][1]}]"
                str_CL_01 += f"Bit_Heap[{counter.inputs[(length - i) * 5 + 7][0]}][{counter.inputs[(length - i) * 5 + 7][1]}]"
                str_CL_02 += f"Bit_Heap[{counter.inputs[(length - i) * 5 + 8][0]}][{counter.inputs[(length - i) * 5 + 8][1]}]"
                str_CL_03 += f"Bit_Heap[{counter.inputs[(length - i) * 5 + 9][0]}][{counter.inputs[(length - i) * 5 + 9][1]}]"
                str_CL_10 += f"Bit_Heap[{counter.inputs[(length - i) * 5 + 10][0]}][{counter.inputs[(length - i) * 5 + 10][1]}]"
                if i != length:
                    str_CL_00 += ", "
                    str_CL_01 += ", "
                    str_CL_02 += ", "
                    str_CL_03 += ", "
                    str_CL_10 += ", "
                else:
                    str_CL_00 += f"}}"
                    str_CL_01 += f"}}"
                    str_CL_02 += f"}}"
                    str_CL_03 += f"}}"
                    str_CL_10 += f"}}"
        else:
            str_C0 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                     f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                     f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[2][0]}][{counter.inputs[2][1]}], " \
                     f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[3][0]}][{counter.inputs[3][1]}], " \
                     f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[4][0]}][{counter.inputs[4][1]}]}}"
            str_C1 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[5][0]}][{counter.inputs[5][1]}]}}"
            for i in range(1, length + 1):
                str_CL_00 += f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[(length - i) * 5 + 6][0]}][{counter.inputs[(length - i) * 5 + 6][1]}]"
                str_CL_01 += f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[(length - i) * 5 + 7][0]}][{counter.inputs[(length - i) * 5 + 7][1]}]"
                str_CL_02 += f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[(length - i) * 5 + 8][0]}][{counter.inputs[(length - i) * 5 + 8][1]}]"
                str_CL_03 += f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[(length - i) * 5 + 9][0]}][{counter.inputs[(length - i) * 5 + 9][1]}]"
                str_CL_10 += f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[(length - i) * 5 + 10][0]}][{counter.inputs[(length - i) * 5 + 10][1]}]"
                if i != length:
                    str_CL_00 += ", "
                    str_CL_01 += ", "
                    str_CL_02 += ", "
                    str_CL_03 += ", "
                    str_CL_10 += ", "
                else:
                    str_CL_00 += f"}}"
                    str_CL_01 += f"}}"
                    str_CL_02 += f"}}"
                    str_CL_03 += f"}}"
                    str_CL_10 += f"}}"
        for j in range(len(counter.outputs)):
            str_O += f"Bit_Heap_L{layer_idx}[{counter.outputs[len(counter.outputs) - 1 - j][0]}][{counter.outputs[len(counter.outputs) - 1 - j][1]}]"
            if j == len(counter.outputs) - 1:
                str_O += f"}}"
            else:
                str_O += ", "
        sv_code = f"""
    Counter_Chain1 #(.LENGTH({length}                        ),
                     .OUTREG("{insert_reg}"                      ),
                     .USETNM("LAYER{layer_idx}_COUNTER_CHAIN1_INST{counter_idx}"))
    Layer{layer_idx}_Counter_Chain1_inst{counter_idx}(
        .clk  (clk),
        .C0   ({str_C0}),
        .C1   ({str_C1}),
        .CL_00({str_CL_00}),
        .CL_01({str_CL_01}),
        .CL_02({str_CL_02}),
        .CL_03({str_CL_03}),
        .CL_10({str_CL_10}),
        .O    ({str_O}));
        """
        xdc_code = ""
        return sv_code, xdc_code

    elif counter.type == "row" and counter.name == "223":
        str_O = f"{{"
        if layer_idx == 0:
            str_C00 = f"{{Bit_Heap[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                     f"Bit_Heap[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                     f"Bit_Heap[{counter.inputs[2][0]}][{counter.inputs[2][1]}]}}"
            str_C01 = f"{{Bit_Heap[{counter.inputs[3][0]}][{counter.inputs[3][1]}], " \
                      f"Bit_Heap[{counter.inputs[4][0]}][{counter.inputs[4][1]}]}}"
            str_C02 = f"{{Bit_Heap[{counter.inputs[5][0]}][{counter.inputs[5][1]}], " \
                      f"Bit_Heap[{counter.inputs[6][0]}][{counter.inputs[6][1]}]}}"
            str_C10 = f"{{Bit_Heap[{counter.inputs[7][0]}][{counter.inputs[7][1]}], " \
                      f"Bit_Heap[{counter.inputs[8][0]}][{counter.inputs[8][1]}]}}"
            str_C11 = f"{{Bit_Heap[{counter.inputs[9][0]}][{counter.inputs[9][1]}], " \
                      f"Bit_Heap[{counter.inputs[10][0]}][{counter.inputs[10][1]}]}}"
            str_C12 = f"{{Bit_Heap[{counter.inputs[11][0]}][{counter.inputs[11][1]}], " \
                      f"Bit_Heap[{counter.inputs[12][0]}][{counter.inputs[12][1]}]}}"
        else:
            str_C00 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                     f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                     f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[2][0]}][{counter.inputs[2][1]}]}}"
            str_C01 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[3][0]}][{counter.inputs[3][1]}], " \
                      f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[4][0]}][{counter.inputs[4][1]}]}}"
            str_C02 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[5][0]}][{counter.inputs[5][1]}], " \
                      f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[6][0]}][{counter.inputs[6][1]}]}}"
            str_C10 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[7][0]}][{counter.inputs[7][1]}], " \
                      f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[8][0]}][{counter.inputs[8][1]}]}}"
            str_C11 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[9][0]}][{counter.inputs[9][1]}], " \
                      f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[10][0]}][{counter.inputs[10][1]}]}}"
            str_C12 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[11][0]}][{counter.inputs[11][1]}], " \
                      f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[12][0]}][{counter.inputs[12][1]}]}}"
        for j in range(len(counter.outputs)):
            str_O += f"Bit_Heap_L{layer_idx}[{counter.outputs[len(counter.outputs) - 1 - j][0]}][{counter.outputs[len(counter.outputs) - 1 - j][1]}]"
            if j == len(counter.outputs) - 1:
                str_O += f"}}"
            else:
                str_O += ", "
        sv_code = f"""
            Counter_Chain2 #(.OUTREG("{insert_reg}"                      ),
                             .USETNM("LAYER{layer_idx}_COUNTER_CHAIN2_INST{counter_idx}"))
            Layer{layer_idx}_Counter_Chain2_inst{counter_idx}(
                .clk(clk),
                .C00({str_C00}),
                .C01({str_C01}),
                .C02({str_C02}),
                .C10({str_C10}),
                .C11({str_C11}),
                .C12({str_C12}),
                .O  ({str_O}));
                """
        xdc_code = f"""
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_Chain2_inst{counter_idx}/Counter_223_inst0/LUT6CY_inst1/LUTCY1_INST]
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_Chain2_inst{counter_idx}/Counter_223_inst0/LUT6CY_inst1/LUTCY2_INST]
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_Chain2_inst{counter_idx}/Counter_223_inst1/LUT6CY_inst1/LUTCY1_INST]
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_Chain2_inst{counter_idx}/Counter_223_inst1/LUT6CY_inst1/LUTCY2_INST]
                """
        return sv_code, xdc_code

    elif counter.type == "terminalAdder":
        col_max = max(counter.input_columns)
        str_C0 = f"Bit_Heap_L{layer_idx - 1}[0][{col_max}:3]"
        str_C1 = f"{{"
        str_C2 = f"{{"
        str_C3 = f"{{"
        for row in range(1, 4):
            buoy_sp = col_max
            buoy_ep = col_max
            zero_cnt = 0
            for col in range(col_max, 2, -1):
                if (row, col) in counter.inputs:
                    buoy_ep = col
                    if zero_cnt != 0:
                        if row == 1:
                            str_C1 += f"{zero_cnt}'b0, "
                        elif row == 2:
                            str_C2 += f"{zero_cnt}'b0, "
                        else:
                            str_C3 += f"{zero_cnt}'b0, "
                        zero_cnt = 0
                else:
                    if zero_cnt == 0 and col != col_max:
                        if row == 1:
                            str_C1 += f"Bit_Heap_L{layer_idx - 1}[{row}][{buoy_sp}:{buoy_ep}], "
                        elif row == 2:
                            str_C2 += f"Bit_Heap_L{layer_idx - 1}[{row}][{buoy_sp}:{buoy_ep}], "
                        else:
                            str_C3 += f"Bit_Heap_L{layer_idx - 1}[{row}][{buoy_sp}:{buoy_ep}], "
                    zero_cnt += 1
                    buoy_sp = col - 1
            if zero_cnt == 0:
                if row == 1:
                    str_C1 += f"Bit_Heap_L{layer_idx - 1}[{row}][{buoy_sp}:{buoy_ep}]}}"
                elif row == 2:
                    str_C2 += f"Bit_Heap_L{layer_idx - 1}[{row}][{buoy_sp}:{buoy_ep}]}}"
                else:
                    str_C3 += f"Bit_Heap_L{layer_idx - 1}[{row}][{buoy_sp}:{buoy_ep}]}}"
            else:
                if row == 1:
                    str_C1 += f"{zero_cnt}'b0}}"
                elif row == 2:
                    str_C2 += f"{zero_cnt}'b0}}"
                else:
                    str_C3 += f"{zero_cnt}'b0}}"
        sv_code = f"""
    Adder_421 #(.IN_WIDTH({col_max - 2}     ),
                .OUTREG  ("TRUE"),
                .LEAVEC  ("TRUE"))
    Layer{layer_idx}_Adder_421_inst{counter_idx}(
        .clk(clk),
        .C0 ({str_C0}),
        .C1 ({str_C1}),
        .C2 ({str_C2}),
        .C3 ({str_C3}),
        .CY0(1'b0),
        .CY1(Bit_Heap_L{layer_idx - 1}[4][4]),
        .O  ({{Adder_to_Counter, Bit_Heap_L{layer_idx}[0][{col_max}:3]}}));
        """
        xdc_code = ""
        return sv_code, xdc_code

    elif counter.type == "head":
        col_max = max(counter.input_columns)
        str_C0 = f"{{Adder_to_Counter[0], Bit_Heap_L{layer_idx - 1}[1][{col_max - 3}], Bit_Heap_L{layer_idx - 1}[0][{col_max - 3}]}}"
        str_C1 = f"{{Adder_to_Counter[1], Bit_Heap_L{layer_idx - 1}[0][{col_max - 2}]}}"
        str_C2 = f"Bit_Heap_L{layer_idx - 1}[0][{col_max-1}]"
        sv_code = f"""
    Counter_123 #(.OUTREG("TRUE"                    ),
                  .USETNM("LAYER{layer_idx}_COUNTER_123_INST{counter_idx}"),
                  .RLOCNM("X0Y0"                    ))
    Layer{layer_idx}_Counter_123_inst{counter_idx}(
        .clk(clk),
        .C0 ({str_C0}),
        .C1 ({str_C1}),
        .C2 ({str_C2}),
        .O  (Bit_Heap_L{layer_idx}[0][{col_max}:{col_max - 3}]));
        """
        xdc_code = f"""
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_123_inst{counter_idx}/LUT6_2_inst1/LUT5]
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_123_inst{counter_idx}/LUT6_2_inst1/LUT6]
set_property BEL       A5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_123_inst{counter_idx}/LUT6_2_inst0/LUT5]
set_property BEL       A6LUT   [get_cells {instname}/Layer{layer_idx}_Counter_123_inst{counter_idx}/LUT6_2_inst0/LUT6]
set_property BEL       B5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_123_inst{counter_idx}/LUT6_2_inst1/LUT5]
set_property BEL       B6LUT   [get_cells {instname}/Layer{layer_idx}_Counter_123_inst{counter_idx}/LUT6_2_inst1/LUT6]
set_property BEL       AFF     [get_cells {instname}/Layer{layer_idx}_Counter_123_inst{counter_idx}/O_reg_reg[0]]
set_property BEL       AFF2    [get_cells {instname}/Layer{layer_idx}_Counter_123_inst{counter_idx}/O_reg_reg[1]]
set_property BEL       BFF     [get_cells {instname}/Layer{layer_idx}_Counter_123_inst{counter_idx}/O_reg_reg[2]]
set_property BEL       BFF2    [get_cells {instname}/Layer{layer_idx}_Counter_123_inst{counter_idx}/O_reg_reg[3]]
        """
        return sv_code, xdc_code

    else:
        if counter.name == "223":
            if layer_idx == 0:
                str_C0 = f"{{Bit_Heap[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                         f"Bit_Heap[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                         f"Bit_Heap[{counter.inputs[2][0]}][{counter.inputs[2][1]}]}}"
                str_C1 = f"{{Bit_Heap[{counter.inputs[3][0]}][{counter.inputs[3][1]}], " \
                         f"Bit_Heap[{counter.inputs[4][0]}][{counter.inputs[4][1]}]}}"
                str_C2 = f"{{Bit_Heap[{counter.inputs[5][0]}][{counter.inputs[5][1]}], " \
                         f"Bit_Heap[{counter.inputs[6][0]}][{counter.inputs[6][1]}]}}"
            else:
                str_C0 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                         f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                         f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[2][0]}][{counter.inputs[2][1]}]}}"
                str_C1 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[3][0]}][{counter.inputs[3][1]}], " \
                         f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[4][0]}][{counter.inputs[4][1]}]}}"
                str_C2 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[5][0]}][{counter.inputs[5][1]}], " \
                         f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[6][0]}][{counter.inputs[6][1]}]}}"
            str_O = f"{{Bit_Heap_L{layer_idx}[{counter.outputs[3][0]}][{counter.outputs[3][1]}], " \
                    f"Bit_Heap_L{layer_idx}[{counter.outputs[2][0]}][{counter.outputs[2][1]}], " \
                    f"Bit_Heap_L{layer_idx}[{counter.outputs[1][0]}][{counter.outputs[1][1]}], " \
                    f"Bit_Heap_L{layer_idx}[{counter.outputs[0][0]}][{counter.outputs[0][1]}]}}"
            sv_code = f""" 
    Counter_223 #(.OUTREG("{insert_reg}"),
                  .USETNM("LAYER{layer_idx}_COUNTER_223_INST{counter_idx}"),
                  .RLOCNM("X0Y0"),
                  .LEAVEC("FALSE"))
    Layer{layer_idx}_Counter_223_inst{counter_idx}(
        .clk (clk),
        .C0  ({str_C0}),
        .C1  ({str_C1}),
        .C2  ({str_C2}),
        .CYX (),
        .PROP(),
        .GE  (),
        .O   ({str_O}));
            """
            xdc_code = f"""
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_223_inst{counter_idx}/LUT6CY_inst1/LUTCY1_INST]
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_223_inst{counter_idx}/LUT6CY_inst1/LUTCY2_INST]
set_property BEL       A5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_223_inst{counter_idx}/LUT6CY_inst0/LUTCY1_INST]
set_property BEL       A5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_223_inst{counter_idx}/LUT6CY_inst0/LUTCY2_INST]
set_property BEL       B5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_223_inst{counter_idx}/LUT6CY_inst1/LUTCY1_INST]
set_property BEL       B5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_223_inst{counter_idx}/LUT6CY_inst1/LUTCY2_INST]
            """
            if insert_reg == "TRUE":
                xdc_code += f"""
set_property BEL       AFF     [get_cells {instname}/Layer{layer_idx}_Counter_223_inst{counter_idx}/O_reg_reg[0]]
set_property BEL       AFF2    [get_cells {instname}/Layer{layer_idx}_Counter_223_inst{counter_idx}/O_reg_reg[1]]
set_property BEL       BFF     [get_cells {instname}/Layer{layer_idx}_Counter_223_inst{counter_idx}/O_reg_reg[2]]
set_property BEL       BFF2    [get_cells {instname}/Layer{layer_idx}_Counter_223_inst{counter_idx}/O_reg_reg[3]]                
                """
            return sv_code, xdc_code

        elif counter.name == "15":
            if layer_idx == 0:
                str_C0 = f"{{Bit_Heap[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                         f"Bit_Heap[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                         f"Bit_Heap[{counter.inputs[2][0]}][{counter.inputs[2][1]}], " \
                         f"Bit_Heap[{counter.inputs[3][0]}][{counter.inputs[3][1]}], " \
                         f"Bit_Heap[{counter.inputs[4][0]}][{counter.inputs[4][1]}]}}"
                str_C1 = f"Bit_Heap[{counter.inputs[5][0]}][{counter.inputs[5][1]}]"
            else:
                str_C0 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                         f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                         f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[2][0]}][{counter.inputs[2][1]}], " \
                         f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[3][0]}][{counter.inputs[3][1]}], " \
                         f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[4][0]}][{counter.inputs[4][1]}]}}"
                str_C1 = f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[5][0]}][{counter.inputs[5][1]}]"
            str_O = f"{{Bit_Heap_L{layer_idx}[{counter.outputs[2][0]}][{counter.outputs[2][1]}], " \
                    f"Bit_Heap_L{layer_idx}[{counter.outputs[1][0]}][{counter.outputs[1][1]}], " \
                    f"Bit_Heap_L{layer_idx}[{counter.outputs[0][0]}][{counter.outputs[0][1]}]}}"
            sv_code = f"""
    Counter_15 #(.OUTREG("{insert_reg}" ),
                 .USETNM("LAYER{layer_idx}_COUNTER_15_INST{counter_idx}"),
                 .RLOCNM("X0Y0" ),
                 .LEAVEC("FALSE" ))
    Layer{layer_idx}_Counter_15_inst{counter_idx}(
        .clk (clk),
        .C0  ({str_C0}),
        .C1  ({str_C1}),
        .O   ({str_O}),
        .PROP(),
        .GE  (),
        .CYX ());
            """
            xdc_code = f"""
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_15_inst{counter_idx}/LUT6CY_inst1/LUTCY1_INST]
set_property LOCK_PINS I4:CASC [get_cells {instname}/Layer{layer_idx}_Counter_15_inst{counter_idx}/LUT6CY_inst1/LUTCY2_INST]
set_property BEL       A5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_15_inst{counter_idx}/LUT6CY_inst0/LUTCY1_INST]
set_property BEL       A5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_15_inst{counter_idx}/LUT6CY_inst0/LUTCY1_INST]
set_property BEL       B5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_15_inst{counter_idx}/LUT6CY_inst1/LUTCY1_INST]
set_property BEL       B5LUT   [get_cells {instname}/Layer{layer_idx}_Counter_15_inst{counter_idx}/LUT6CY_inst1/LUTCY1_INST]
            """
            if insert_reg == "TRUE":
                xdc_code += f"""
set_property BEL       AFF     [get_cells {instname}/Layer{layer_idx}_Counter_15_inst{counter_idx}/O_reg_reg[0]]
set_property BEL       BFF     [get_cells {instname}/Layer{layer_idx}_Counter_15_inst{counter_idx}/O_reg_reg[1]]
set_property BEL       BFF2    [get_cells {instname}/Layer{layer_idx}_Counter_15_inst{counter_idx}/O_reg_reg[2]]                
                """
            return sv_code, xdc_code

        elif counter.name == "3":
            if layer_idx == 0:
                str_C0 = f"{{Bit_Heap[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                         f"Bit_Heap[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                         f"Bit_Heap[{counter.inputs[2][0]}][{counter.inputs[2][1]}]}}"
            else:
                str_C0 = f"{{Bit_Heap_L{layer_idx - 1}[{counter.inputs[0][0]}][{counter.inputs[0][1]}], " \
                         f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[1][0]}][{counter.inputs[1][1]}], " \
                         f"Bit_Heap_L{layer_idx - 1}[{counter.inputs[2][0]}][{counter.inputs[2][1]}]}}"
            str_O = f"{{Bit_Heap_L{layer_idx}[{counter.outputs[1][0]}][{counter.outputs[1][1]}], " \
                    f"Bit_Heap_L{layer_idx}[{counter.outputs[0][0]}][{counter.outputs[0][1]}]}}"
            sv_code = f"""
    Counter_3to2 #(.OUTREG("{insert_reg}" ))
    Layer{layer_idx}_Counter_3to2_inst{counter_idx}(
        .clk(clk),
        .C0 ({str_C0}),
        .O  ({str_O}));
                """
            xdc_code = ""
            return sv_code, xdc_code


def gen_sv_assignment(layer: Layer, insert_reg, lastLayerFlag):
    sv_code = ""
    if insert_reg == "FALSE" and lastLayerFlag is False:
        if layer.index == 0:
            for previous, present in layer.assign_list:
                sv_code += f"""
    assign Bit_Heap_L{layer.index}[{present[0]}][{present[1]}] = Bit_Heap[{previous[0]}][{previous[1]}];"""
            return sv_code
        else:
            for previous, present in layer.assign_list:
                sv_code += f"""
    assign Bit_Heap_L{layer.index}[{present[0]}][{present[1]}] = Bit_Heap_L{layer.index - 1}[{previous[0]}][{previous[1]}];"""
            return sv_code
    else:
        sv_code += f"""
        always_ff @(posedge clk) begin"""
        if layer.index == 0:
            for previous, present in layer.assign_list:
                sv_code += f"""
            Bit_Heap_L{layer.index}[{present[0]}][{present[1]}] <= Bit_Heap[{previous[0]}][{previous[1]}];"""
            sv_code += f"""
        end"""
            return sv_code
        else:
            for previous, present in layer.assign_list:
                sv_code += f"""
            Bit_Heap_L{layer.index}[{present[0]}][{present[1]}] <= Bit_Heap_L{layer.index - 1}[{previous[0]}][{previous[1]}];"""
            sv_code += f"""
        end"""
            return sv_code


def gen_sv_onelayer(layer: Layer, instname, insert_reg, lastLayerFlag):
    sv_code = f"""

    logic [2*IN_WIDTH-1 : 0] Bit_Heap_L{layer.index} [IN_WIDTH/2 : 0];
    """
    xdc_code = ""
    for i in range(len(layer.counter_list)):
        sv, xdc = gen_sv_onecounter(layer.counter_list[i], layer.index, i, instname, insert_reg)
        sv_code += sv
        xdc_code += xdc
    sv_code += gen_sv_assignment(layer, insert_reg, lastLayerFlag)
    return sv_code, xdc_code


def gen_sv_output(lastlayer_idx):
    sv_code = f"""

    assign P[2*IN_WIDTH-1 : 0] = Bit_Heap_L{lastlayer_idx}[0];
    """
    return sv_code


def gen_sv_all(layer_list: list, multWidth, multStage):
    pipeList = ["FALSE", "FALSE", "FALSE", "FALSE", "FALSE", "FALSE"]
    if multWidth <= 10:
        if multStage == 2:
            pipeList[1] = "TRUE"
        elif multStage > 2:
            pipeList[0] = "TRUE"
            pipeList[1] = "TRUE"
    elif multWidth <= 24:
        if multStage == 2:
            pipeList[1] = "TRUE"
        elif multStage == 3:
            pipeList[0] = "TRUE"
            pipeList[1] = "TRUE"
        elif multStage > 3:
            pipeList[0] = "TRUE"
            pipeList[1] = "TRUE"
            pipeList[2] = "TRUE"
    elif multWidth <= 46:
        if multStage == 2:
            pipeList[1] = "TRUE"
        elif multStage == 3:
            pipeList[1] = "TRUE"
            pipeList[2] = "TRUE"
        elif multStage == 4:
            pipeList[0] = "TRUE"
            pipeList[1] = "TRUE"
            pipeList[2] = "TRUE"
        elif multStage > 4:
            pipeList[0] = "TRUE"
            pipeList[1] = "TRUE"
            pipeList[2] = "TRUE"
            pipeList[3] = "TRUE"
    else:
        if multStage == 2:
            pipeList[2] = "TRUE"
        elif multStage == 3:
            pipeList[1] = "TRUE"
            pipeList[2] = "TRUE"
        elif multStage == 4:
            pipeList[1] = "TRUE"
            pipeList[2] = "TRUE"
            pipeList[3] = "TRUE"
        elif multStage == 5:
            pipeList[0] = "TRUE"
            pipeList[1] = "TRUE"
            pipeList[2] = "TRUE"
            pipeList[3] = "TRUE"
        elif multStage > 6:
            pipeList[0] = "TRUE"
            pipeList[1] = "TRUE"
            pipeList[2] = "TRUE"
            pipeList[3] = "TRUE"
            pipeList[4] = "TRUE"

    sv_code = gen_sv_bitheap(multWidth, multStage, pipeList[0])
    xdc_code = f"""\
create_clock -period 10 -name clk_gen -add [get_ports clk]
            """

    for layer in layer_list:
        sv, xdc = gen_sv_onelayer(layer, f"Mult_LUTs_{multWidth}_inst", pipeList[layer.index+1], layer.index == len(layer_list)-1)
        sv_code += sv
        xdc_code += xdc
    sv_code += gen_sv_output(layer_list[-1].index)
    sv_code += f"""
endmodule"""
    return sv_code, xdc_code


if __name__ == '__main__':
    multWidth = 32
    multStage = 3
    realBitHeap = BitHeap(2*multWidth)

    for p in range(multWidth // 2):
        for q in range(2 * p, 2 * multWidth - 2 * p):
            realBitHeap.heap[q].addbits(1)
        realBitHeap.heap[2 * p].addbits(1)
    realBitHeap.heap[multWidth].addbits(1)

    realBitHeap.visualize(f"{multWidth}Times{multWidth}_original")

    realBitHeap_layers = do_compression(realBitHeap, multWidth)
    for layer in realBitHeap_layers:
        print(layer.counter_list)
        print(layer.assign_list)
    countLUTs(realBitHeap_layers, multWidth)

    sv_code, xdc_code = gen_sv_all(realBitHeap_layers, multWidth, multStage)
    with open(f"Mult_LUTs_{multWidth}.sv", "w") as f_sv:
        f_sv.write(sv_code)
        f_sv.close()
    with open(f"Mult_LUTs_{multWidth}.xdc", "w") as f_xdc:
        f_xdc.write(xdc_code)
        f_xdc.close()